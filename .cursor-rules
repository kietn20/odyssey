# These are the official engineering standards for Project Odyssey.
# As our AI co-pilot, you MUST adhere to these rules for all code generation,
# refactoring, and assistance to ensure consistency, reliability, and maintainability
# across our entire multi-service, polyglot codebase.

###########################################################
# Global & Project-Wide Rules
###########################################################

# Rule 1: Explicit File Paths and Purpose
# Every new file you create must start with a comment block detailing its
# full path from the project root and a brief description of its purpose.
# Example:
# // File: /services/telemetry-service/internal/server/server.go
# // Purpose: Defines the main gRPC server and its lifecycle methods.
FilePaths: Always include a comment block at the top of new files specifying the full path and purpose.

# Rule 2: Documentation First
# All exported functions or classes must be preceded by a comment block
# explaining what it does, its parameters, and what it returns. Use the idiomatic
# documentation style for each language (GoDoc for Go, JSDoc/TSDoc for TypeScript).
Documentation: All exported functions, classes, and public API methods must have clear documentation.

# Rule 3: No Hardcoded Secrets or Configuration
# All configuration values (ports, database URLs, API keys, hostnames) must be loaded
# from environment variables. Provide a `.env.example` file for new services,
# and add the actual `.env` file to the .gitignore. Never hardcode these values in the code.
Configuration: Use environment variables for all configuration. Add `.env` files to `.gitignore`.

# Rule 4: Atomic Commits
# When asked to generate a commit message, it must follow the conventional commit format:
# `feat: add drone telemetry endpoint` or `fix: correct websocket message parsing`.
# The description should be concise and focused on a single logical change.
Commits: Generate commit messages using the conventional commit format.

###########################################################
# Go (Backend Services) Rules
###########################################################

# Rule 5: Rigorous Error Handling
# In Go, never use a blank identifier `_` to discard an error from a function call.
# Every error must be checked. Handle it gracefully (e.g., with structured logging)
# or return it up the call stack.
GoErrors: Always check and handle errors; never discard them.

# Rule 6: Structured Logging Only
# For all backend logging, use the standard `log/slog` library for structured logging.
# Do not use `fmt.Println` or the basic `log.Println` for server output.
# Log key-value pairs to provide context.
# Example: `slog.Error("Failed to connect to database", "error", err)`
GoLogging: Use `log/slog` for structured, key-value pair logging.

# Rule 7: Strict Project Structure
# Follow the standard Go project layout. Service-specific logic should be in an `/internal` directory.
# Reusable code can be in `/pkg`. The main entry point should be in `/cmd/service-name/main.go`.
GoStructure: Adhere to the `cmd`, `internal`, `pkg` project layout.

# Rule 8: Concurrency Safety
# When introducing concurrency with goroutines, always explain the concurrency model and
# justify the use of channels, mutexes, or waitgroups to prevent race conditions.
GoConcurrency: Explicitly state the strategy for ensuring concurrency safety when using goroutines.

###########################################################
# TypeScript/React (Frontend) Rules
###########################################################

# Rule 9: Functional Components and Hooks
# All new React components MUST be functional components using Hooks.
# Class components are strictly forbidden.
ReactComponents: Use functional components and Hooks exclusively.

# Rule 10: Strict Typing
# The use of the `any` type is strictly forbidden. Define clear interfaces or types for all
# props, API responses, and state objects.
TypeScript: Do not use the `any` type. Define explicit types and interfaces for everything.

# Rule 11: State Management Philosophy
# For simple, component-local state, use `useState`. For complex global state shared
# across many components, use Zustand. Do not use Context API for frequently
# changing global state to avoid performance issues.
ReactState: Use Zustand for complex global state, not Context.

# Rule 12: Component Structure
# Each React component MUST be in its own directory, named in PascalCase.
# The directory should contain the component file (`Component.tsx`) and its
# corresponding CSS module file (`Component.module.css`).
ReactFiles: Each component must live in its own self-named directory with its styles.

###########################################################
# Python (Simulators) Rules
###########################################################

# Rule 13: Full Type Hinting
# All function signatures in Python code MUST include type hints for all parameters and
# return values, in accordance with PEP 484.
PythonTypes: All Python function signatures must have full type hints.

# Rule 14: PEP 8 Compliance
# All generated Python code must be formatted to comply with the PEP 8 style guide.
# Use an automated formatter like Black if necessary to ensure consistency.
PythonStyle: Adhere to the PEP 8 style guide.

# Rule 15: Dependency Management
# Use `pip` with a `requirements.txt` file for managing Python dependencies.
# Do not assume packages are globally installed.
PythonDeps: Manage dependencies with a `requirements.txt` file.